#set verbose off

/*
      This function performs the asymptotic Conditional Predictive Ability Test
      Raffaella Giacomini & Halbert White, 2006. "Tests of Conditional Predictive
      Ability," Econometrica, Econometric Society, vol. 74(6), pages 1545-1578, November.
      <https://ideas.repec.org/a/ecm/emetrp/v74y2006i6p1545-1578.html>      


       # Which model will give better forecasts in the future.
       # Diebold-Mariano and West (1996) type tests rather test which of two models better approximates the DGP
       "As a result, whereas the unconditional tests restrict attention to the forecast model, the conditional
       approach allows evaluation of the forecasting method, which includes the model, the estimation
       procedure and the possible cond of estimation window."

       # INPUTS:
       L		series, series of over the out of sample period for the two models under consideration
       inst		list, list of additional exoganous/conditional regressors
       hor		int, forecast horizon
       alpha	scalar, mininal risk level: 1%, 5%, 10%
       cond: 	int, 0=unconditional, 1=conditional
       
       % OUTPUTS: teststat, the test statistic of the conditional predictive ability test
       %          critval, the critical value of the test for a 5% level (the test is a chi square)
       %          pval, the p-value of the test
       %
       % Raffaella Giacomini, 2003
*/


function bundle CPAtest (const series y "realization",
    const series fc1 "forecasts 1st model",
    const series fc2 "forecasts 2nd model",
      list inst[null] "Specify additional exogenous",
      int hor[1::] "forecast horizon",
      scalar alpha[0.01:0.1:0.05] "Minimal risk level",
      int cond "0=unconditional, 1=conditional",
      bool verbose[1] "print detail: 0=no, 1=yes")

      bundle b = null
      series L = (y-fc1)^2 - (y-fc2)^2
      scalar T = nobs(L)-hor
      list inst += const
    
    # set up the instruments
    if cond==1
        inst += L(-hor to -hor)			# set information set available in period t for the t+h forecast
    endif
    
    # create the regressor matrix given by lossdiff*ht', where ht is the matrix of instruments
    list reg = null
    loop foreach jj inst -q
        series r$jj = inst.$jj*L
        reg+=r$jj
    endloop
    df = nelem(reg)
    
    if hor == 1
        # calculate the test stat as nR^2 from the regression of one on lossdiff*ht
        ols 0 reg  -q
        teststat = $T*$rsq			# this only works for hor=1!s
        pval = pvalue(c,df,abs(teststat))
    else
    /*	THIS WOULD ONLY WORK FOR h=1 but not h>1!
       sprintf hacl "%d", (hor-1)
       set hac_lag @hacl
       ols 0 reg --robust 
       if cond==1
       restrict --wald --full
       b[1]=0
       end restrict
       else
       restrict --wald --full
       b[1]=0
       b[2]=0
       end restrict
       endif
       pval = $pvalue
       teststat = $test
        */
        
        matrix zbar = meanc({reg})'
        matrix omega = NeweyWest({reg},(hor-1))
        teststat = T*zbar'*inv(omega)*zbar
    endif        
    pval = pvalue(c,df,abs(teststat))     
    critval = critical(c,df,alpha)

    avgL = mean(L)

    if avgL<0
        string sign="(-) -- 1st model dominates"
    elif avgL>0
        string sign="(+) -- 2nd model dominates"
    endif

    if verbose
        printf "\n------------------------------------------------------------------\n"
        printf " Giacomini & White (2006) Tests of Conditional Predictive Ability\n"
        if cond==0
            printf "\nYour choice: \tUnconditional Test\n"
        else
            printf "\nYour choice: \tConditional Test\n"
        endif
        printf "Forecast horizon: %d\n", hor
        printf "Nominal risk level: %1.2f\n", alpha
        printf "-----------------------------------------------\n"
        printf "Test-statistic: %1.2f %s\n", teststat, sign
        printf "Critical Value: %1.2f\n", critval
        printf "P-value: %1.3f\n" , pval
    endif
    
    b.avgL = avgL
    b.tstat = teststat
    b.critval = critval
    b.pval = pval
    return b
end function

function matrix NeweyWest (matrix Z, int nlags)
    # Returns the Newey-West estimator of the asymptotic variance matrix
    # INPUTS: Z, a nxk matrix with rows the vector zt'
    #         nlags, the number of lags
    #
    # OUTPUTS: omegahat, the Newey-West estimator of the covariance matrix

    scalar n = rows(Z)
    scalar k = cols(Z)
    
    Z = cdemean(Z)    		# de-mean the variables
    matrix gamma = zeros(nlags,k)
    matrix omegahat = Z'Z/n		# sample variance
    
    if nlags > 0
        #sample autocovariances
        loop for ii=1..nlags -q
            Zlag = zeros(ii,k) | Z[1:n-ii,]
            gamma = (Z'Zlag +Zlag'Z)/n
            w = 1 - (ii/(nlags+1))
            omegahat = omegahat + w*gamma
        endloop
    endif    
    return omegahat
end function


###########################
/*
# EXAMPLE
#----------
set verbose off
include FEP.gfn
open FEPdata.gdt --frompkg=FEP

#------------------
# Diebold & Mariano
bundle b = null
b.y = DS_RBIP_t		# Realized series
b.f1 = RBIP_t		# FC 1 series
b.f2 = RBIP_t(-1)	# FC 2 series
b.loss = 2			# 1="U-shape", 2="V-shape" 
b.verbose = 1		# 0=print NO details, 1=print details
scalar b.fhor = 1	# if b.ssc!=0 one needs to provide info in the forecast horizon
applyFCtests(&b, "DM")
print b

#---------
# CPA test
y = DS_RBIP_t		# Realized series
f1 = RBIP_t			# FC 1 series
f2 = RBIP_t(-1)		# FC 2 series

scalar hor=1				# hor "forecast horizon",
scalar alpha=0.05 			# "Minimal risk level",
scalar cond=1				# "0=unconditional, 1=conditional"
list inst = null
bundle b  = CPAtest(y, f1, f2, inst, hor, alpha, cond,1)
print b
*/
