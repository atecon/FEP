# private functions

function void check_series_in_b (const bundle b, const string which)
    printf "Test choice: %s\n", which

    if (which=="DM" || which=="GW" || which=="HP" || which=="MZ" || which == "CW") \
          && !inbundle(b, "y")

        funcerr "Series of realizations 'y' is missing."
        # Strictly speaking: also need to check type of y

    elif (which=="HP" || which=="MZ") && !inbundle(b, "fc")
        funcerr "Series of forecasts values 'fc' is missing."

    elif (which=="CG" || which=="EKT") && !inbundle(b, "E") && \
          ( !inbundle(b, "y") || !inbundle(b, "fc") )
        funcerr "Both series of realizations 'y' and of forecasts 'fc' must be passed. (Or errors 'E'.)"

    elif (which=="DM" || which=="GW" || which == "CW") && !inbundle(b, "f1")
        funcerr "Series of forecast values 'f1' is missing."

    elif (which=="DM" || which=="GW" || which == "CW") && !inbundle(b, "f2")
        funcerr "Series of forecast values 'f1' is missing."

    elif (which=="DL" || which=="KS" || which=="PT" || which=="PS") && !inbundle(b, "yup")
        funcerr "Binary indicator series of realizations 'yup' is missing."

    elif (which=="DL" || which=="KS" || which=="PT") && !inbundle(b, "fcup")
        funcerr "Binary indicator series of forecasts 'fcup' is missing."

    elif which=="PS" && !inbundle(b, "pfc")
        funcerr "Probability forecast series 'pfc' is missing."

    elif (which=="EKT" || which=="HP") && !inbundle(b, "z")
        funcerr "List of exogenous / instruments 'z' is missing."

    endif
end function


function scalar loadextra(void)
    # Pull in the extra pkg for the Wilcoxon p-values
    # needed in the doCGtest

    # (Until extra.gfn allows introspection for its version,
    # we use this warning workaround).
    string warn = "(FEP needs extra.gfn version 0.41 or higher."
    warn = sprintf("%s\nOtherwise expect errors,", warn)
    warn = sprintf("%s then install a newer version of 'extra'.)\n", warn)

    catch include extra.gfn
    if $error
        catch install extra
        if $error
            print "Fatal problem getting the 'extra' package."
            print "Please install it manually and try again."
            print "(Tests except CG should still work,"
            print "  otherwise expect more errors ahead...)"
            return 2

        else
            catch include extra.gfn
            if $error
                print "Fatal error loading the 'extra' package."
                print "(Tests except CG should still work,"
                print "  otherwise expect more errors ahead...)"
                return 1

            else
                print warn
                return 0
            endif

        endif

    else
        print warn
        return 0
    endif
end function

################

function scalar check_y_fc_length (const series y, const list fc)
    /* Check number of valid observations. Needed for ForecastMetrics(). */
    
    scalar ret = 0			# no. of fc-series which have less valid obs. than series y
    scalar Ty = nobs(y)
    
    loop foreach i fc -q
        scalar d = nobs(fc.$i)-Ty

        if d < 0
            ret++
            string case = "less"
        elif d > 0
            ret++
            string case = "more"
        endif
        if d != 0
            printf "\nWarning: Forecast series '%s' has %d %s valid observations than your \n\
              series of realizations\n", varnames(fc)[i], abs(d), case
        endif
    endloop

    return ret
end function

function matrix add_labels (const matrix metrics)
    /* Helper function adding row- and column-labels. Needed for ForecastMetrics(). */
    
    strings cnames = array(cols(metrics))
    loop i=1..cols(metrics) -q
        cnames[i] = sprintf("Forecast_$i")
    endloop
    cnameset(metrics, cnames)
    
    strings rnames = names_of_basic_point_metrics() + names_of_udf_point_metrics()
    rnameset(metrics, rnames)

    return metrics    
end function

function matrix basic_point_metrics (const series y, const list fc)
    /* Call built-in gretl function. */
    return fcstats(y, fc)[1:5,]		# discard Theil's U + associated statistics
end function

function strings names_of_basic_point_metrics (void)
    return defarray("ME", "RMSE", "MAE", "MPE", "MAPE")
end function

function strings names_of_udf_point_metrics (void)
    return defarray("MdAPE", "RMSPE", "RMdSPE", "sMAPE", "sMdAPE", \
      "sMAAPE", "sMdAAPE", "MdE", "MdAE", "MAM", "MdAMd")
end function

function matrix get_pct_error_metrics (const series y, const list fc)
    /* Wrapper retrieving various percentage error metrics */
    
    list fc_error = get_fc_error_list(y, fc)
    matrix metrics = {} 

    metrics |= MdAPE(y, fc_error)'
    metrics |= RMdSPE(y, fc_error)'
    metrics |= RMdSPE(y, fc_error, 1)'
    metrics |= sMdAPE(y, fc_error)'
    metrics |= sMdAPE(y, fc_error, 1)'
    metrics |= sMdAAPE(y, fc_error)'
    metrics |= sMdAAPE(y, fc_error, 1)'
    metrics |= MdE(fc_error)'
    metrics |= MdAE(fc_error)'
    metrics |= MADMean(y, fc_error)'
    metrics |= MADMean(y, fc_error, 1)'

    return metrics
end function


function matrix MADMean (const series y, const list fc, bool use_median[0])
    /* Mean (median) absolute error scaled by the sample mean (median)
    of realizations. Proposed by Kolassa and SchÃ¼tz (2007):
    "Advantages of the MAD/Mean Ratio over the MAPE",
      Foresight: The International Journal of Applied Forecasting, 6 (2007),
      pp. 40-43. See also:
      https://www.sciencedirect.com/science/article/pii/S0169207016000121#br000070 */
    
    matrix metric = zeros(nelem(fc),1)
    loop foreach i fc -q
        if use_median
            metric[i] = median(abs(get_fc_error(y, fc.$i))) / median(y)
        else
            metric[i] = mean(abs(get_fc_error(y, fc.$i))) / mean(y)
        endif
    endloop
    
    return metric
end function


function matrix MdE (const list fc_error)
    /* Median error */
     
    matrix metric = zeros(nelem(fc_error),1)
    loop foreach i fc_error -q
        metric[i] = median(fc_error.$i)
    endloop
        
    return metric
end function


function matrix MdAE (const list fc_error)
    /* Median absolute error */
     
    matrix metric = zeros(nelem(fc_error),1)
    loop foreach i fc_error -q
        metric[i] = median(abs(fc_error.$i))
    endloop
        
    return metric
end function


function matrix sMdAPE (const series y, const list fc, bool use_median[0])
    /* Symmetric mean/ median absolute percentage error */
    
    matrix metric = zeros(nelem(fc),1)
    loop foreach i fc -q
        if use_median
            metric[i] = median( 200* abs(get_fc_error(y, fc.$i)) / (y+fc.$i) )
        else
            metric[i] = mean( 200* abs(get_fc_error(y, fc.$i)) / (y+fc.$i) )
        endif
    endloop
    
    return metric
end function


function matrix sMdAAPE (const series y, const list fc, bool use_median[0])
    /* Symmetric mean/ median absolute absolute percentage error */
    
    matrix metric = zeros(nelem(fc),1)
    loop foreach i fc -q
        if use_median
            metric[i] = median( 200* abs(get_fc_error(y, fc.$i)) / abs((y+fc.$i)) )
        else
            metric[i] = mean( 200* abs(get_fc_error(y, fc.$i)) / abs((y+fc.$i)) )
        endif
    endloop
    
    return metric
end function


function matrix RMdSPE (const series y, const list fc_error, bool use_median[0])
    /* Root mean/ median square percentage error -- based on percentage errors */
     
    matrix metric = zeros(nelem(fc_error),1)
    loop foreach i fc_error -q
        if use_median
            metric[i] = sqrt(median(pct_error(y, fc_error.$i)^2))
        else
            metric[i] = sqrt(mean(pct_error(y, fc_error.$i)^2))
        endif        
    endloop

    return metric
end function


function matrix MdAPE (const series y, const list fc_error)
    /* Median absolute percentage error -- based on percentage errors */
     
    matrix metric = zeros(nelem(fc_error),1)
    loop foreach i fc_error -q
        metric[i] = median( abs( pct_error(y, fc_error.$i) ) )
    endloop
        
    return metric
end function


function list get_fc_error_list (const series y, const list fc)
    /* Compute list of forecast errors */
    
    list fc_error = null
    loop foreach i fc -q
        series err_$i = get_fc_error(y, fc.$i)
        list fc_error += err_$i
    endloop
    
    return fc_error
end function


function series pct_error (const series y, const series fc_error)
    /* Compute percentage error series */    
    return 100 * fc_error / y
end function


function series get_fc_error (const series y, const series fc)
    /* Compute forecast error series */        
    return y - fc
end function

#########


function void set_robust_flag (bundle *b)
    /* For avoiding code duplicity. */

    if !inbundle(b, "robust")
        scalar b.robust = 0
    endif
end function

function void set_verbatim_flag (bundle *b)
    /* For avoiding code duplicity. */

    if !inbundle(b, "verb")
        b.verb = 0
    endif
end function


function void set_fhor_default (bundle *b)
    /* For avoiding code duplicity. */

    if !inbundle(b, "fhor")
        b.fhor = 1
    endif
end function


function void CGprint(bundle *b)
    printf "********************************************************\n"
    if !b.k && !inbundle(b, "CGX")
        printf "You selected the test(s) of unbiasedness.\n"

    elif !b.k && inbundle(b, "CGX")
        funcerr "You set k=0 but provided CGX. Please set k>0, and re-run."
    endif

    if b.k > 0 && !inbundle(b, "CGX")
        printf "You selected the test(s) of (no) serial correlation at lag %d.\n", b.k

    elif inbundle(b, "CGX")
        printf "You selected the test(s) of orthogonality at lag %d.\n", b.k
    endif
    printf "********************************************************\n"
end function

#################

function string fullname(string scode)
    strings codes = defarray("MZ","KG","DL","EKT","KS","PT", \
      "CGRANK","CGWILC","DM","GW", \
      "HP", "PS", "CG", "CW")
    strings fulls = defarray("Mincer-Zarnowitz (MZ)",
      "Holden-Peel-Kirchgaessner (KG)",
      "Diebold-Lopez (DL)",
      "Elliott-Komunjer-Timmermann (EKT)",
      "Kuiper score (KS)",
      "Pesaran-Timmermann (PT)",
      "Campbell-Ghysels rank sign (CGRANK)",
      "Campbell-Ghysels Wilcoxon sign (CGWILC)",
      "Diebold-Mariano (DM)",
      "Giacomini-White (GW)",
      "Holden-Peel (HP)",
      "Probability Score (PS)",
      "Campbell-Ghysels (CG)",
      "Clark-West (CW)")

    loop i=1..nelem(codes) -q
        if scode == codes[i]
            return fulls[i]
        endif
    endloop

    # When we get here it's a problem
    printf "Whoops, scode is %s\n", scode
    funcerr "Code scode didn't match anything"
end function

#################

function matrix HLN (scalar DMstat "Diebold-Mariano test statistics",
                     int T "No. of forecasts",
                     int h "Forecast horizon")
    matrix stat = DMstat / sqrt( (T+1-2*h+h*(h-1)/T)/T )
    matrix pv = 2*pvalue(t,(T-1),abs(stat))
    return pv
end function

function void try_invert (matrix m,
                          scalar *err)
    catch matrix ret = inv(m)
    err = $error
end function

function void try_ginvert (matrix m,
                           scalar *err)
    catch matrix ret = ginv(m)
    err = $error
end function

###############

function matrix symtest (scalar aT "AlphaHat",
                         scalar SE "S.D. of  Alpha",
                         int verb)
    # Test the null hypothesis of symmetry: alfa = 0.5 #
    scalar TestSym = (aT - 0.5)/SE
    scalar ProbSym = 2*(pvalue(z,abs(TestSym)))	# alfa is asymptotically normal
    if verb==1
        printf "\n*********************************************\n"
        printf "Test for Symmetry: H0: aT=0.5 vs. H1: aT!=0.5\n"
        printf "\nEstim. alpha = %12.3g\n", aT
        printf "Test stat. = %12.3g\n", TestSym
        printf "P-value = %12.3g\n", ProbSym
        printf "\n*********************************************\n"
    endif
    return TestSym ~ ProbSym
end function


function matrix rattest (matrix Y,
                         matrix iv,
                         matrix vMod,
                         scalar aT "AlphaHat",
                         matrix s,
                         int iSym[0:1:] "0=Use estimated aT, 1=Fix aT=0.5",
                         int verb)
    if iSym==0 && cols(s)==1
        printf "Error: Rationality Test not applicable\n\
          as the no. of instruments equal the no. of parameters\n"
        J = NA
        pv = NA
    elif cols(s)>1
        if iSym==1
            aT = 0.5
            df = cols(s)
        else
            df = cols(s)-1
        endif
        A = sumc( iv.*((Y.<0)-aT).*vMod)
        err = 0
        try_invert(s,&err)
        if err==0
            J = qform(A,inv(s)) / rows(iv)
        else
            err = 0
            try_ginvert(s,&err)
            if err==0
                J = qform(A,ginv(s)) / rows(iv)
            endif
        endif
    endif
    if cols(s)>1 && err==0
        pv = pvalue(X,df,J)
        if cols(s)>1 && verb==1
            printf "\n*********************************************\n"
            printf "Rationality Test\n"
            if iSym==1
                printf "\nAlpha fixed to 0.5\n"
            else
                printf "\nEstim. alpha = %12.3g\n", aT
            endif
            printf "J-statistics = %12.3g\n", J
            printf "P-value = %12.3g\n", pv
            printf "\n*********************************************\n"
        endif
        return J~pv
    else
        return {NA}~{NA}
    endif
end function


function matrix NeweyWest (matrix Z, int nlags)
    # For Giacomini-White test
    # Returns the Newey-West estimator of the asymptotic variance matrix
    # INPUTS: Z, a nxk matrix with rows the vector zt'
    #         nlags, the number of lags
    #
    # OUTPUTS: omegahat, the Newey-West estimator of the covariance matrix

    scalar n = rows(Z)
    scalar k = cols(Z)

    Z = cdemean(Z)    		# de-mean the variables
    if nlags>0
        matrix gamma = zeros(nlags,k)
    endif
    matrix omegahat = Z'Z/n		# sample variance

    if nlags > 0
        #sample autocovariances
        loop ii=1..nlags -q
            Zlag = zeros(ii,k) | Z[1:n-ii,]
            gamma = (Z'Zlag +Zlag'Z)/n
            w = 1 - (ii/(nlags+1))
            omegahat = omegahat + w*gamma
        endloop
    endif
    return omegahat
end function
