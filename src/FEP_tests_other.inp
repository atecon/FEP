# index:
# doDMtest (Diebold-Mariano)
# doGWtest (Giacomini-White)
# doCWtest (Clark-West)

##############
function void doDMtest (bundle *b)

    # apply defaults
    set_verbatim_flag(&b)
    if !inbundle(b, "loss")
        b.loss = 1	# U-shape
    endif
    set_fhor_default(&b)

    series e1 = b.y - b.f1
    series e2 = b.y - b.f2
    smpl e1 e2 --no-missing

    # Construct loss differential
    # TODO: Allow for further loss functions in future
    if b.loss == 1		# U-shape quadratic loss
        series L = e1^2 - e2^2
    elif b.loss == 2		# V-shape
        series L = abs(e1) - abs(e2)
    else
        printf "\n*** You can choose only between loss=1 (U-shape)"
		printf " and loss=2 (V-shape). ***\n"
        printf "*** Please re-specify b.loss.\n"
        funcerr "Loss can only be 1 or 2."
    endif

    # Run regression based HAC robust DM test
    ols L 0 --robust --quiet
    # Return test statistics and p-value
    b.L = L									# series of loss differentials
    scalar tstat = $coeff / $stderr
    b.DMstat = tstat
    b.pvaln = 2 * pvalue(z, abs(tstat))			# stand. normal
    b.pvalt = 2 * pvalue(t, ($T-1), abs(tstat))	# t-distribution
    matrix ssc = HLN(tstat, $T, b.fhor)		# small-sample correction
	b.DMstatssc = ssc[1]
	b.DMpvalssc = ssc[2]

    if b.verb
        printf "\n***********************************************\n"
        printf "*** Diebold & Mariano (1995) \n"
        printf "*** test of equal forecast accuracy\n"
        if b.fhor == 0
            printf "\n*** Warning: You have set the forecast horizon
			printf " to h=0.\n"
        endif
        if b.loss == 1
            printf "\nLoss: U-shape quadratic.\n"
        elif b.loss == 2
            printf "\nLoss: V-shape linear.\n"
        endif
        printf "Forecast horizon: %d \n", b.fhor
        printf "H0: forecasts are equally accurate\n"
        printf "Test statistic: \t%.4f\n", b.DMstat
        printf "p-val (stand. normal): \t%.4f\n", b.pvaln
        printf "p-val (t-distr): \t%.4f\n", b.pvalt
		printf "Test stat (small-sample corrected): %.4f\n", b.DMstatssc  
        printf "p-val (small-sample): \t%.4f\n", b.DMpvalssc
        printf "***********************************************\n"
    endif

end function


################

function void doGWtest (bundle *b)
/*
   This function performs the asymptotic Conditional Predictive Ability Test
   Raffaella Giacomini & Halbert White, 2006. "Tests of Conditional 
	Predictive Ability," Econometrica, Econometric Society, vol. 74(6), 
	pages 1545-1578, November.
   <https://ideas.repec.org/a/ecm/emetrp/v74y2006i6p1545-1578.html>

   "As a result, whereas the unconditional tests restrict attention to 
	the forecast model, the conditional approach allows evaluation of 
	the forecasting method, which includes the model, the estimation
	procedure and the possible cond of estimation window."
    */

    # apply defaults
    set_verbatim_flag(&b)
    if !inbundle(b, "loss")
        b.loss = 1	# U-shape
    endif
    set_fhor_default(&b)
    if b.fhor == 0
        printf "\n*** Warning: You have set the forecast horizon to h=0.\n"
    endif

    if !inbundle(b, "cond")
        b.cond = 0	# 0: unconditional test
    endif

    series e1 = b.y - b.f1
    series e2 = b.y - b.f2
    smpl e1 e2 --no-missing

    # Construct loss differential
    # TODO: Allow for further loss functions in future
    if b.loss == 1			# U-shape quadratic loss
        series L = e1^2 - e2^2
    elif b.loss == 2		# V-shape
        series L = abs(e1) - abs(e2)
    endif

    scalar T = nobs(L) - b.fhor

    list z = const
    # set up the instruments for a conditional analysis
    if b.cond
        # add lagged loss values -- 
		# info set available in period t for the t+h forecast
        z += L(-b.fhor to -b.fhor)

        # add additional regressor
        if inbundle(b, "z")
            # compatibility for matrix input of z
            if typestr(typeof(b.z)) == "matrix"
                matrix mz = b.z
                loop i = 1..cols(mz) -q
                    series S$i = mz[,i]
                    z += S$i
                endloop
            elif typestr(typeof(b.z)) == "series" 
				# (workaround for apparent gretl bug)
                list z += genseries("z", b.z)
            else	# standard list case
                list z += b.z
            endif
        endif
    endif

    # create the reg matrix given by L*ht', where ht is matrix of instr
    list reg = null
    loop foreach i z -q
        series r$i = z.$i * L
        reg += r$i
    endloop
    df = nelem(reg)

    # Run regression
    if b.fhor == 1
        # calc the test stat as n*R^2 from the regression of one on L*ht
        ols 0 reg -q
        scalar tstat = $T*$rsq			# this only works for hor=1!
    else
        matrix zbar = meanc({reg})'
        matrix omega = NeweyWest({reg},(b.fhor-1))
        scalar tstat = T*zbar'*inv(omega)*zbar
    endif

    # Return test statistics and p-value
    b.L = L								# series of loss differentials
    b.GWstat = tstat
    b.GWpval = pvalue(c,df,abs(tstat))  # Chi^2 distributed
    b.sign = mean(L)

    if b.verb
        printf "\n***********************************************\n"
        printf "*** Giacomini & White (2006) \n"
        printf "*** test of conditional predictive ability\n"
        if b.loss==1
            printf "\nLoss: U-shape quadratic.\n"
        elif b.loss==2
            printf "\nLoss: V-shape linear.\n"
        endif
        if b.cond==0
            printf "Choice: \t\tUnconditional Test\n"
            if inbundle(b, "z")
                printf "Additional variables in element 'z' are thus "
				printf "not considered.\n"
            endif
        else
            printf "Your choice: \tConditional Test\n"
        endif
        printf "Forecast horizon: %d \n", b.fhor
        printf "H0: forecasts are equally accurate\n"
        printf "Test stat = %.4f ", b.GWstat
        printf "(p-val, chi^2-distr: %.4f)\n", b.GWpval
        if b.sign < 0
            printf "Sign of mean loss: (-) -- 1st model dominates\n"
        else
            printf "Sign of mean loss: (+) -- 2nd model dominates\n"
        endif
        printf "***********************************************\n"
    endif
end function

###############

# Clark & West: APPROXIMATELY NORMAL TEST FOR EQUALPREDICTIVE ACCURACY
# IN NESTED MODELS (2006/2007)

function void doCWtest (bundle *b)
    # All: b.y, 
    # Model 1: b.f1, parsimonious model
    # Model 2: b.f2, larger nesting model

    series e1 = b.y - b.f1
    series e2 = b.y - b.f2
    smpl e1 e2 --no-missing

    series fhathalf = e1 * (e1 - e2) # equiv. to eq 2.1 hopefully

    ## for simplicity compute both standard and robust
    ols fhathalf const --quiet
	# ( omit const  # doesn't work in gretl)
    b.CWstat = $coeff(const) / $stderr(const)
    b.CWpval = pvalue(t, $df, b.CWstat) # one-sided test
	# robust
    set force_hc off	# ensure AC-consistency, not just HC
    ols fhathalf const --robust --quiet
    b.CWstat_rob = $coeff(const) / $stderr(const)
    b.CWpval_rob = pvalue(t, $df, b.CWstat_rob) # one-sided test

    if b.verb
        printf "\n***********************************************\n"
        printf "*** Clark & West (2006/7) test\n"
        printf "*** of equal forecast accuracy in nested models\n"
        # printf "Forecast horizon: %d \n", b.fhor
        printf "H0: forecasts are equally accurate\n"
        printf "Test stat = %.4f", b.CWstat
        printf " (p-val, t-distr: %.4f)\n", b.CWpval
		printf "Robust version\n"
		printf "Test stat = %.4f", b.CWstat_rob
        printf " (p-val, t-distr: %.4f)\n", b.CWpval_rob
        printf "***********************************************\n"
    endif

end function
